<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>é˜¿é¹¿é¹¿æ–‡å‰µï¼èŠ±åª½æ¥æ¥æ¨‚</title>

  <!-- LIFF SDKï¼ˆæŠ“åå­—ç”¨ï¼‰ -->
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>

  <!-- html2canvasï¼šç”¨ä¾†æˆªåœ– -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    :root {
      --bg1: #ffd1e6;
      --bg2: #fff0f7;
      --card: #ffffffcc;
      --text: #111;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      background: linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow: hidden;
    }

    #game {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #hud {
      position: absolute;
      top: calc(12px + env(safe-area-inset-top));
      left: 12px;
      right: 12px;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .hudRow {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
    }

    .pill {
      pointer-events: auto;
      background: var(--card);
      border-radius: 18px;
      padding: 10px 14px;
      font-weight: 900;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .10);
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text);
      backdrop-filter: blur(6px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pill.small {
      font-weight: 900;
      padding: 10px 12px;
    }

    #titlePill {
      flex: 0 1 auto;
      max-width: 62vw;
    }

    #welcomePill {
      flex: 1 1 auto;
    }

    #btnRestartTop,
    #btnMute {
      pointer-events: auto;
      border: none;
      background: #fff;
      border-radius: 18px;
      padding: 10px 12px;
      font-weight: 1000;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .10);
      cursor: pointer;
      white-space: nowrap;
    }

    #player {
      position: absolute;
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      width: 78px;
      height: 78px;

      background: transparent;
      border-radius: 0;
      box-shadow: none;

      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5;

      overflow: visible;
      will-change: left;
    }

    #playerImg {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: none;
    }

    #playerEmoji {
      font-size: 46px;
      display: block;
      line-height: 1;
    }

    .item {
      position: absolute;
      width: 54px;
      height: 54px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 38px;
      filter: drop-shadow(0 10px 12px rgba(0, 0, 0, .12));
      will-change: transform;
      z-index: 4;
      pointer-events: none;
    }

    #ground {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 18px;
      background: rgba(0, 0, 0, .06);
      z-index: 2;
    }

    .overlay {
      position: absolute;
      inset: 0;
      z-index: 999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      background: rgba(255, 255, 255, .86);
    }

    .card {
      width: min(560px, 92vw);
      background: #fff;
      border-radius: 24px;
      padding: 18px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, .16);
      display: flex;
      flex-direction: column;
      gap: 10px;
      text-align: center;
    }

    .title {
      font-size: 26px;
      font-weight: 1000;
      line-height: 1.2;
    }

    .desc {
      text-align: left;
      background: #fafafa;
      border: 1px solid #eee;
      border-radius: 18px;
      padding: 12px;
      font-weight: 900;
      font-size: 14px;
      line-height: 1.6;
    }

    .btn {
      border: none;
      border-radius: 18px;
      padding: 12px 14px;
      font-size: 16px;
      font-weight: 1000;
      cursor: pointer;
    }

    .btn.primary {
      background: #111;
      color: #fff;
    }

    .btn.secondary {
      background: #fff;
      border: 1px solid #ddd;
      color: #111;
    }

    .muted {
      opacity: .7;
      font-size: 12px;
    }

    #loadingBarWrap {
      height: 12px;
      border-radius: 999px;
      background: #eee;
      overflow: hidden;
      border: 1px solid #e5e5e5;
    }

    #loadingBar {
      height: 100%;
      width: 0%;
      background: #111;
      border-radius: 999px;
      transition: width .12s linear;
    }

    #shotFrame {
      border-radius: 22px;
      padding: 14px;
      background: linear-gradient(180deg, #fff, #fff7fb);
      border: 1px solid #f1e1ea;
    }

    #shotHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    #shotBrand {
      font-weight: 1000;
      letter-spacing: .5px;
    }

    #shotDate {
      font-size: 12px;
      opacity: .75;
      font-weight: 1000;
    }

    #finalScore {
      font-size: 20px;
      font-weight: 1000;
    }

    #lb {
      margin-top: 6px;
      text-align: left;
      background: #fafafa;
      border-radius: 18px;
      padding: 12px;
      border: 1px solid #eee;
    }

    #lbTitle {
      font-weight: 1000;
      margin-bottom: 8px;
    }

    .lbRow {
      display: flex;
      justify-content: space-between;
      padding: 6px 8px;
      border-radius: 12px;
      background: #fff;
      border: 1px solid #f0f0f0;
      margin-bottom: 6px;
      font-weight: 900;
      font-size: 14px;
    }

    #previewImg {
      width: min(520px, 92vw);
      border-radius: 18px;
      border: 1px solid #eee;
      box-shadow: 0 18px 50px rgba(0, 0, 0, .16);
      background: #fff;
    }
  </style>
</head>

<body>
  <div id="game">
    <div id="hud">
      <div class="hudRow">
        <div class="pill" id="titlePill">ğŸ¦’ é˜¿é¹¿é¹¿æ–‡å‰µï¼èŠ±åª½æ¥æ¥æ¨‚</div>
        <button id="btnMute" title="éŸ³æ•ˆ/éŸ³æ¨‚">ğŸ”Š</button>
      </div>

      <div class="hudRow">
        <div class="pill" id="welcomePill">è¼‰å…¥åå­—ä¸­â€¦</div>
        <button id="btnRestartTop" title="é‡æ–°é–‹å§‹">é‡æ–°é–‹å§‹</button>
      </div>

      <div class="hudRow">
        <div class="pill small">åˆ†æ•¸ï¼š<span id="score">0</span></div>
        <div class="pill small">å‘½ï¼š<span id="lives">5</span> â¤ï¸</div>
        <div class="pill small">é€Ÿåº¦ï¼š<span id="speed">1</span></div>
      </div>
    </div>

    <div id="player" aria-label="player">
      <img id="playerImg" alt="èŠ±åª½" />
      <div id="playerEmoji">ğŸ¦’</div>
    </div>

    <div id="ground"></div>

    <div id="loading" class="overlay" style="display:flex;">
      <div class="card">
        <div class="title">ç´ æè¼‰å…¥ä¸­â€¦</div>
        <div class="muted">åœ–ç‰‡è¼‰ä¸åˆ°ä¹Ÿæœƒè‡ªå‹•é€²å…¥ï¼ˆä¸æœƒå¡ä½ï¼‰âœ…</div>
        <div id="loadingBarWrap">
          <div id="loadingBar"></div>
        </div>
        <div class="muted" id="loadingText">0%</div>
      </div>
    </div>

    <div id="start" class="overlay">
      <div class="card">
        <div class="title">ğŸ“£ æ´»å‹•èªªæ˜ï½œé˜¿é¹¿é¹¿æ–‡å‰µï¼èŠ±åª½æ¥æ¥æ¨‚</div>
        <div class="desc">
          âœ… ç©æ³•ï¼šæ‹–æ›³èŠ±åª½å·¦å³ç§»å‹•ï¼Œæ¥ä½æ‰ä¸‹ä¾†çš„é£Ÿæï¼<br />
          ğŸ¥¦ğŸ¥• æ¥åˆ°ã€ŒèŠ±æ¤°èœ / ç´…è˜¿è””ã€+1 åˆ†<br />
          ğŸª¨ æ¥åˆ°ã€ŒçŸ³é ­ã€-1 å‘½<br />
          âš ï¸ é£Ÿææ‰åˆ°åœ°ä¸Šä¹Ÿæœƒ -1 å‘½ï¼ˆåˆºæ¿€ç‰ˆï¼‰<br />
          â¤ï¸ å‘½æ­¸é›¶å°± Game Overï¼Œå¯ä¸‹è¼‰æˆç¸¾å¡åˆ†äº«çµ¦å¤§å®¶ï½<br />
          âœ¨ é€£çºŒæ¥åˆ° 3 å€‹ä»¥ä¸Šæœƒè§¸ç™¼ã€Œåˆ‡èœ Comboã€å’šå’šå’šå’šï¼
        </div>
        <button class="btn primary" id="btnStart">é–‹å§‹éŠæˆ²</button>
        <div class="muted">æç¤ºï¼šéŸ³æ¨‚éœ€è¦é»æ“Šå¾Œæ‰å…è¨±æ’­æ”¾ï¼ˆæŒ‰é–‹å§‹å°±æœƒé–‹ BGMï¼‰</div>
      </div>
    </div>

    <div id="gameover" class="overlay">
      <div class="card" id="gameoverCard">
        <div class="title">Game Over</div>

        <div id="shotFrame">
          <div id="shotHeader">
            <div id="shotBrand">ğŸ¦’ é˜¿é¹¿é¹¿æ–‡å‰µï¼èŠ±åª½æ¥æ¥æ¨‚</div>
            <div id="shotDate"></div>
          </div>
          <div id="finalScore">åˆ†æ•¸ï¼š0</div>
          <div class="muted">ã€Œä¸€éµå­˜åˆ°æ‰‹æ©Ÿã€è‹¥ä¸æ”¯æ´ï¼Œæœƒæ”¹ç”¨é è¦½é•·æŒ‰å­˜åœ– âœ…</div>

          <div id="lb">
            <div id="lbTitle">ğŸ† èŠ±åª½æœ€å¼·æ¥æ¥æ¦œï¼ˆæœ¬æ©Ÿï¼‰</div>
            <div id="lbList"></div>
            <div class="muted">â€» ç›®å‰ç‚ºåŒè£ç½®/åŒç€è¦½å™¨ä¿å­˜</div>
          </div>
        </div>

        <button class="btn primary" id="btnDownload">ä¸‹è¼‰æˆç¸¾å¡ï¼ˆç”¢ç”Ÿåœ–ç‰‡ï¼‰</button>
        <button class="btn primary" id="btnShareImage">ä¸€éµå­˜åˆ°æ‰‹æ©Ÿï¼ˆåˆ†äº«åœ–ç‰‡ï¼‰</button>
        <button class="btn secondary" id="btnRestart">å†ç©ä¸€æ¬¡</button>

        <div class="muted">â€» LINE å…§å»ºç€è¦½å™¨é€šå¸¸ä¸èƒ½ã€Œç¶²é ç›´æ¥å¯«å…¥ç›¸ç°¿ã€ï¼Œæ‰€ä»¥æœƒç”¨åˆ†äº«/é è¦½ç•¶ä½œæœ€ç©©æ–¹æ¡ˆ</div>
      </div>
    </div>

    <div id="preview" class="overlay">
      <div class="card">
        <div class="title">ğŸ–¼ï¸ æˆç¸¾åœ–ç‰‡é è¦½</div>
        <img id="previewImg" alt="score preview" />
        <div class="muted">æ‰‹æ©Ÿï¼šé•·æŒ‰åœ–ç‰‡ â†’ å„²å­˜åœ–ç‰‡ï¼ˆåœ¨ LINE å…§æœ€ç©©ï¼‰</div>
        <button class="btn secondary" id="btnClosePreview">é—œé–‰</button>
      </div>
    </div>
  </div>

  <script>
    /**********************
     *  âœ… ä½ çš„ LIFF IDï¼ˆæ–°ç¶²å€ï¼‰
     **********************/
    const LIFF_ID = "2008833499-r2OWdk57";

    /**********************
     *  âœ… èŠ±åª½å»èƒŒåœ–
     **********************/
    const PLAYER_IMG_URL = "https://github.com/z883662/Aruru/blob/main/lulu3.png?raw=true";

    /**********************
     *  âœ… æ‰è½ç‰©è¨­å®š
     **********************/
    const GOOD_ITEMS = ["ğŸ¥¦", "ğŸ¥•"];
    const BAD_ITEM = "ğŸª¨"; // âœ… çŸ³é ­

    /**********************
     *  âœ… èŠ±åª½å¯æ„›éŸ³æ•ˆï¼šå¯æ„›BGM + åˆ‡èœCombo + çŸ³é ­æ‚¶æ’è²
     **********************/
    let audioCtx = null;
    let muted = false;

    // BGM
    let bgmOn = true;
    let bgmTimer = null;
    let bgmStarted = false;
    let bgmStep = 0;

    // combo
    let comboCount = 0;
    let comboTimer = null;

    function ensureAudio() {
      if (muted) return;
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) audioCtx = new AC();
      }
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => { });
      }
    }

    function tone(freq, t0, dur, type, gain) {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }

    function beep(freq = 440, duration = 0.08, type = "sine", gain = 0.06) {
      if (muted) return;
      ensureAudio();
      if (!audioCtx) return;
      tone(freq, audioCtx.currentTime, duration, type, gain);
    }

    function chopOnce(gain = 0.10) {
      if (muted) return;
      ensureAudio();
      if (!audioCtx) return;

      const t0 = audioCtx.currentTime;

      const bufferSize = Math.floor(audioCtx.sampleRate * 0.06);
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        const decay = 1 - i / bufferSize;
        data[i] = (Math.random() * 2 - 1) * decay * 0.65;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;

      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.0001, t0);
      ng.gain.exponentialRampToValueAtTime(gain, t0 + 0.005);
      ng.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.06);

      const o = audioCtx.createOscillator();
      const og = audioCtx.createGain();
      o.type = "square";
      o.frequency.setValueAtTime(200, t0);
      o.frequency.exponentialRampToValueAtTime(130, t0 + 0.03);

      og.gain.setValueAtTime(0.0001, t0);
      og.gain.exponentialRampToValueAtTime(gain * 0.55, t0 + 0.003);
      og.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.05);

      noise.connect(ng);
      ng.connect(audioCtx.destination);

      o.connect(og);
      og.connect(audioCtx.destination);

      noise.start(t0);
      noise.stop(t0 + 0.065);

      o.start(t0);
      o.stop(t0 + 0.06);
    }

    function chopCombo() {
      chopOnce(0.11);
      setTimeout(() => chopOnce(0.10), 70);
      setTimeout(() => chopOnce(0.10), 140);
      setTimeout(() => chopOnce(0.11), 210);
    }

    // âœ… çŸ³é ­æ‚¶æ’è²ï¼šä½é »å’š + ä¸€é»å™ªéŸ³ï¼ˆä¸åƒé‡‘å±¬ï¼‰
    function rockThud(gain = 0.10) {
      if (muted) return;
      ensureAudio();
      if (!audioCtx) return;

      const t0 = audioCtx.currentTime;

      // ä½é »ã€Œå’šã€
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.setValueAtTime(120, t0);
      o.frequency.exponentialRampToValueAtTime(55, t0 + 0.10);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.16);

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start(t0);
      o.stop(t0 + 0.18);

      // å°‘é‡å™ªéŸ³ã€Œæ²™æ²™ã€å¢åŠ æ’æ“Šè³ªæ„Ÿ
      const bufferSize = Math.floor(audioCtx.sampleRate * 0.04);
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        const decay = 1 - i / bufferSize;
        data[i] = (Math.random() * 2 - 1) * decay * 0.35;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.0001, t0);
      ng.gain.exponentialRampToValueAtTime(gain * 0.35, t0 + 0.005);
      ng.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.07);
      noise.connect(ng);
      ng.connect(audioCtx.destination);
      noise.start(t0);
      noise.stop(t0 + 0.08);
    }

    function startBGM() {
      if (bgmStarted || muted || !bgmOn) return;
      ensureAudio();
      if (!audioCtx) return;

      bgmStarted = true;
      bgmStep = 0;

      const melody = [392, 440, 523, 440, 392, 330, 294, 330, 392, 440, 392, 330];
      const chords = [
        [262, 330, 392],
        [349, 440, 523],
        [392, 494, 587],
        [440, 523, 659],
      ];

      const tick = () => {
        if (muted || !bgmOn || !audioCtx) return;

        const t0 = audioCtx.currentTime;
        const beat = 0.165;

        const m = melody[bgmStep % melody.length];
        const ch = chords[Math.floor((bgmStep / 4) % chords.length)];

        tone(m, t0, 0.14, "triangle", 0.030);
        ch.forEach((f, i) => tone(f, t0, 0.16, "sine", 0.010 - i * 0.001));

        if (bgmStep % 4 === 0) {
          tone(1046, t0, 0.06, "sine", 0.015);
        }

        bgmStep++;
        bgmTimer = setTimeout(tick, beat * 1000);
      };

      tick();
    }

    function stopBGM() {
      bgmStarted = false;
      if (bgmTimer) clearTimeout(bgmTimer);
      bgmTimer = null;
    }

    function bumpCombo() {
      comboCount++;
      if (comboTimer) clearTimeout(comboTimer);
      comboTimer = setTimeout(() => {
        comboCount = 0;
        comboTimer = null;
      }, 700);
    }

    const sfx = {
      start() {
        beep(523, 0.09, "triangle", 0.06);
        setTimeout(() => beep(659, 0.09, "triangle", 0.06), 90);
        startBGM();
      },
      good() {
        bumpCombo();
        if (comboCount >= 3) {
          chopCombo();
          setTimeout(() => beep(988, 0.05, "sine", 0.03), 40);
          setTimeout(() => beep(1175, 0.05, "sine", 0.03), 95);
        } else {
          chopOnce(0.11);
          setTimeout(() => beep(880, 0.05, "sine", 0.028), 18);
        }
      },
      bad() {
        rockThud(0.11);
      },
      drop() {
        beep(220, 0.08, "sawtooth", 0.04);
      },
      gameover() {
        stopBGM();
        beep(196, 0.12, "square", 0.06);
        setTimeout(() => beep(147, 0.16, "square", 0.06), 120);
      }
    };

    /**********************
     *  DOM
     **********************/
    const game = document.getElementById("game");
    const playerEl = document.getElementById("player");
    const playerImg = document.getElementById("playerImg");
    const playerEmoji = document.getElementById("playerEmoji");

    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");
    const speedEl = document.getElementById("speed");
    const welcomePill = document.getElementById("welcomePill");

    const loadingEl = document.getElementById("loading");
    const loadingBar = document.getElementById("loadingBar");
    const loadingText = document.getElementById("loadingText");

    const startEl = document.getElementById("start");
    const btnStart = document.getElementById("btnStart");

    const gameoverEl = document.getElementById("gameover");
    const finalScoreEl = document.getElementById("finalScore");

    const btnDownload = document.getElementById("btnDownload");
    const btnShareImage = document.getElementById("btnShareImage");

    const btnRestartTop = document.getElementById("btnRestartTop");
    const btnRestart = document.getElementById("btnRestart");
    const btnMute = document.getElementById("btnMute");

    const shotDate = document.getElementById("shotDate");
    const shotFrame = document.getElementById("shotFrame");

    const previewEl = document.getElementById("preview");
    const previewImg = document.getElementById("previewImg");
    const btnClosePreview = document.getElementById("btnClosePreview");

    /**********************
     *  éŠæˆ²ç‹€æ…‹ï¼ˆæ•ˆèƒ½ç‰ˆï¼‰
     **********************/
    const playerW = 78;
    const playerH = 78;
    const itemW = 54;
    const itemH = 54;

    let vw = window.innerWidth;
    let vh = window.innerHeight;
    const playerBottom = 22;

    const items = [];
    let playerX = vw * 0.5;

    let score = 0;
    let lives = 5;

    let running = false;
    let inRound = false;
    let lastSpawn = 0;

    let spawnInterval = 900;
    let speedBase = 220;

    let lastT = performance.now();
    let dragging = false;

    let playerName = "é¹¿ç²‰";
    let lastScoreImageDataUrl = "";

    const rand = (min, max) => Math.random() * (max - min) + min;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    function computeSpeedLevel() {
      return Math.max(1, Math.min(99, Math.round((speedBase - 220) / 30) + 1));
    }

    function updateHUD() {
      scoreEl.textContent = String(score);
      livesEl.textContent = String(lives);
      speedEl.textContent = String(computeSpeedLevel());
    }

    function setPlayerX(x) {
      playerX = clamp(x, playerW / 2 + 8, vw - playerW / 2 - 8);
      playerEl.style.left = playerX + "px";
    }

    function clearItems() {
      for (const it of items) it.el.remove();
      items.length = 0;
    }

    function intersects(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    /**********************
     *  æ’è¡Œæ¦œï¼ˆlocalStorageï¼‰
     **********************/
    const LB_KEY = "alulu_catch_huama_v1_r2OWdk57";
    function loadLeaderboard() {
      try {
        const raw = localStorage.getItem(LB_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch (_) { return []; }
    }
    function saveLeaderboard(list) {
      localStorage.setItem(LB_KEY, JSON.stringify(list));
    }
    function addToLeaderboard(name, score) {
      const list = loadLeaderboard();
      list.push({ name, score, ts: Date.now() });
      list.sort((a, b) => b.score - a.score);
      const top = list.slice(0, 10);
      saveLeaderboard(top);
      return top;
    }
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, m => ({
        "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;"
      }[m]));
    }
    function renderLeaderboard(list) {
      const box = document.getElementById("lbList");
      box.innerHTML = "";
      if (!list.length) {
        box.innerHTML = `<div class="muted">é‚„æ²’æœ‰ç´€éŒ„ï¼Œå¿«ç•¶ç¬¬ä¸€åï¼</div>`;
        return;
      }
      list.forEach((r, i) => {
        const row = document.createElement("div");
        row.className = "lbRow";
        row.innerHTML = `<div>${i + 1}. ${escapeHtml(r.name || "é¹¿ç²‰")}</div><div>${r.score}</div>`;
        box.appendChild(row);
      });
    }

    function setCheerName(name) {
      const clean = (name && String(name).trim()) ? String(name).trim() : "???";
      welcomePill.textContent = `é¹¿ç²‰ ${clean} åŠ æ²¹`;
    }

    async function initPlayerName() {
      setCheerName("???");
      try {
        if (typeof liff === "undefined") return;

        await liff.init({ liffId: LIFF_ID });

        if (typeof liff.isLoggedIn === "function" && !liff.isLoggedIn()) {
          return;
        }

        const p = await liff.getProfile();
        if (p && p.displayName) {
          playerName = p.displayName;
          setCheerName(p.displayName);
        }
      } catch (_) { }
    }

    function setLoading(p) {
      const pct = Math.max(0, Math.min(100, Math.round(p * 100)));
      loadingBar.style.width = pct + "%";
      loadingText.textContent = pct + "%";
    }

    function loadImageWithTimeout(url, timeoutMs = 3500) {
      return new Promise((resolve) => {
        const img = new Image();
        let done = false;

        const finish = (ok) => {
          if (done) return;
          done = true;
          resolve(ok);
        };

        const timer = setTimeout(() => {
          try { img.src = ""; } catch (_) { }
          finish(false);
        }, timeoutMs);

        img.onload = () => { clearTimeout(timer); finish(true); };
        img.onerror = () => { clearTimeout(timer); finish(false); };

        const bust = (url.includes("?") ? "&" : "?") + "v=" + Date.now();
        img.src = url + bust;
      });
    }

    async function preloadAssets() {
      loadingEl.style.display = "flex";
      setLoading(0);

      let fake = 0;
      const fakeTimer = setInterval(() => {
        fake = Math.min(0.9, fake + 0.05);
        setLoading(fake);
      }, 120);

      const ok = await loadImageWithTimeout(PLAYER_IMG_URL, 3500);

      clearInterval(fakeTimer);

      if (ok) {
        playerImg.src = PLAYER_IMG_URL;
        playerImg.style.display = "block";
        playerEmoji.style.display = "none";
      } else {
        playerImg.removeAttribute("src");
        playerImg.style.display = "none";
        playerEmoji.style.display = "block";
      }

      setLoading(1);
      loadingEl.style.display = "none";
      startEl.style.display = "flex";
    }

    function spawnItem() {
      const el = document.createElement("div");
      el.className = "item";

      const isGood = Math.random() < 0.55;
      el.textContent = isGood
        ? GOOD_ITEMS[Math.floor(Math.random() * GOOD_ITEMS.length)]
        : BAD_ITEM;

      const x = rand(12, vw - itemW - 12);
      const y = -70;

      el.style.transform = `translate(${x}px, ${y}px)`;
      game.appendChild(el);

      const speed = speedBase + rand(-30, 90);
      items.push({ el, x, y, speed, isGood });
    }

    function startGame() {
      if (inRound) return;
      inRound = true;

      ensureAudio();

      running = true;
      score = 0;
      lives = 5;
      spawnInterval = 900;
      speedBase = 220;

      comboCount = 0;
      if (comboTimer) clearTimeout(comboTimer);
      comboTimer = null;

      clearItems();
      updateHUD();
      gameoverEl.style.display = "none";
      startEl.style.display = "none";
      previewEl.style.display = "none";

      setPlayerX(vw * 0.5);

      sfx.start();
      lastSpawn = performance.now();
      lastT = performance.now();
    }

    function showGameOver() {
      running = false;
      inRound = false;

      comboCount = 0;
      if (comboTimer) clearTimeout(comboTimer);
      comboTimer = null;

      sfx.gameover();

      finalScoreEl.textContent = `åˆ†æ•¸ï¼š${score}`;
      const top = addToLeaderboard(playerName, score);
      renderLeaderboard(top);

      const d = new Date();
      shotDate.textContent =
        `${d.getFullYear()}/${String(d.getMonth() + 1).padStart(2, "0")}/${String(d.getDate()).padStart(2, "0")} ` +
        `${String(d.getHours()).padStart(2, "0")}:${String(d.getMinutes()).padStart(2, "0")}`;

      gameoverEl.style.display = "flex";
    }

    function dataURLtoBlob(dataurl) {
      const arr = dataurl.split(",");
      const mime = arr[0].match(/:(.*?);/)[1];
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while (n--) u8arr[n] = bstr.charCodeAt(n);
      return new Blob([u8arr], { type: mime });
    }

    async function generateScoreImage() {
      const canvas = await html2canvas(shotFrame, {
        backgroundColor: "#ffffff",
        scale: 2,
        useCORS: true
      });
      const dataUrl = canvas.toDataURL("image/png");
      lastScoreImageDataUrl = dataUrl;
      return dataUrl;
    }

    async function downloadScoreCard() {
      btnDownload.disabled = true;
      const old = btnDownload.textContent;
      btnDownload.textContent = "è£½ä½œåœ–ç‰‡ä¸­â€¦";

      try {
        const dataUrl = await generateScoreImage();

        try {
          const blob = dataURLtoBlob(dataUrl);
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          const d = new Date();
          const stamp = `${d.getFullYear()}${String(d.getMonth() + 1).padStart(2, "0")}${String(d.getDate()).padStart(2, "0")}_${String(d.getHours()).padStart(2, "0")}${String(d.getMinutes()).padStart(2, "0")}`;
          a.download = `é˜¿é¹¿é¹¿æ–‡å‰µï¼èŠ±åª½æ¥æ¥æ¨‚_æˆç¸¾_${stamp}.png`;
          a.href = url;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1500);
        } catch (_) { }

        previewImg.src = dataUrl;
        previewEl.style.display = "flex";

        beep(880, 0.06, "triangle", 0.05);
      } catch (err) {
        alert("âŒ æˆªåœ–å¤±æ•—ï¼š" + (err?.message || err));
      }

      btnDownload.disabled = false;
      btnDownload.textContent = old;
    }

    async function shareScoreImage() {
      btnShareImage.disabled = true;
      const old = btnShareImage.textContent;
      btnShareImage.textContent = "æº–å‚™åˆ†äº«ä¸­â€¦";

      try {
        if (!lastScoreImageDataUrl) {
          await generateScoreImage();
        }

        const blob = dataURLtoBlob(lastScoreImageDataUrl);
        const file = new File([blob], "score.png", { type: "image/png" });

        if (navigator.canShare && navigator.canShare({ files: [file] }) && navigator.share) {
          await navigator.share({
            files: [file],
            title: "é˜¿é¹¿é¹¿æ–‡å‰µï¼èŠ±åª½æ¥æ¥æ¨‚ æˆç¸¾",
            text: "æˆ‘çš„æˆç¸¾ä¾†å•¦ï¼"
          });
        } else {
          previewImg.src = lastScoreImageDataUrl;
          previewEl.style.display = "flex";
          alert("é€™å°æ‰‹æ©Ÿä¸æ”¯æ´ã€ä¸€éµåˆ†äº«æª”æ¡ˆã€ï½å·²æ”¹ç”¨é è¦½é•·æŒ‰å­˜åœ– âœ…");
        }
      } catch (err) {
        if (lastScoreImageDataUrl) {
          previewImg.src = lastScoreImageDataUrl;
          previewEl.style.display = "flex";
        }
      }

      btnShareImage.disabled = false;
      btnShareImage.textContent = old;
    }

    function toggleMute() {
      muted = !muted;
      btnMute.textContent = muted ? "ğŸ”‡" : "ğŸ”Š";

      if (muted) {
        stopBGM();
      } else {
        ensureAudio();
        beep(660, 0.06, "triangle", 0.05);
        if (running) startBGM();
      }
    }

    game.addEventListener("pointerdown", (e) => {
      dragging = true;
      game.setPointerCapture?.(e.pointerId);
      setPlayerX(e.clientX);
      ensureAudio();
    });

    game.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      setPlayerX(e.clientX);
    });

    game.addEventListener("pointerup", (e) => {
      dragging = false;
      game.releasePointerCapture?.(e.pointerId);
    });

    game.addEventListener("pointercancel", () => {
      dragging = false;
    });

    function loop(t) {
      const dt = (t - lastT) / 1000;
      lastT = t;

      if (running) {
        if (t - lastSpawn > spawnInterval) {
          spawnItem();
          lastSpawn = t;

          spawnInterval = Math.max(260, spawnInterval - 10);
          speedBase = Math.min(820, speedBase + 3.0);
          updateHUD();
        }

        const px = playerX - playerW / 2;
        const py = vh - playerBottom - playerH;

        for (let i = items.length - 1; i >= 0; i--) {
          const it = items[i];

          it.y += it.speed * dt;
          it.el.style.transform = `translate(${it.x}px, ${it.y}px)`;

          if (intersects(px, py, playerW, playerH, it.x, it.y, itemW, itemH)) {
            if (it.isGood) {
              score += 1;
              sfx.good();
            } else {
              lives -= 1;
              sfx.bad();
            }

            updateHUD();
            it.el.remove();
            items.splice(i, 1);

            if (lives <= 0) {
              showGameOver();
              break;
            }
            continue;
          }

          if (it.y > vh + 100) {
            if (it.isGood) {
              lives -= 1;
              sfx.drop();
              updateHUD();
              if (lives <= 0) {
                it.el.remove();
                items.splice(i, 1);
                showGameOver();
                break;
              }
            }
            it.el.remove();
            items.splice(i, 1);
          }
        }
      }

      requestAnimationFrame(loop);
    }

    btnStart.addEventListener("click", startGame);

    btnRestartTop.addEventListener("click", () => {
      running = false;
      inRound = false;
      clearItems();
      startEl.style.display = "flex";
      gameoverEl.style.display = "none";
      previewEl.style.display = "none";
      lastScoreImageDataUrl = "";

      stopBGM();
      comboCount = 0;
      if (comboTimer) clearTimeout(comboTimer);
      comboTimer = null;

      score = 0; lives = 5; spawnInterval = 900; speedBase = 220;
      updateHUD();
      ensureAudio();
      beep(440, 0.06, "triangle", 0.04);
    });

    btnRestart.addEventListener("click", () => {
      lastScoreImageDataUrl = "";
      startGame();
    });

    btnDownload.addEventListener("click", downloadScoreCard);
    btnShareImage.addEventListener("click", shareScoreImage);
    btnMute.addEventListener("click", toggleMute);
    btnClosePreview.addEventListener("click", () => previewEl.style.display = "none");

    function init() {
      welcomePill.textContent = "è¼‰å…¥åå­—ä¸­â€¦";
      btnMute.textContent = "ğŸ”Š";

      setPlayerX(playerX);
      updateHUD();
      renderLeaderboard(loadLeaderboard());

      requestAnimationFrame(loop);

      initPlayerName();
      preloadAssets();
    }

    window.addEventListener("resize", () => {
      vw = window.innerWidth;
      vh = window.innerHeight;
      setPlayerX(playerX);
    });

    init();
  </script>
</body>

</html>
